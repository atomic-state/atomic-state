/**  @license Atomic State
 * Copyright (c) Dany Beltran
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * An observable class that uses the observer pattern
 */ class Observervable{constructor(){this.suscribers={}}async addSubscriber(a,b){a in this.suscribers||(this.suscribers[a]={});let c=Object.keys(this.suscribers[a]).length+1;"__proto__"!==a&&"prototype"!==a?this.suscribers[a][c]=b:console.warn('"prototype" and "__proto__" are not valid message names')}async removeSubscriber(a,c){for(let b in this.suscribers[a])this.suscribers[a][b]===c&&delete this.suscribers[a][b]}async update(a,b){for(let c in this.suscribers[a])await this.suscribers[a][c](b)}}function createObserver(){let a=new Observervable;return{observer:a,notify:function(b,c,d){a.update(b,{storeName:b,hookCall:c,payload:d})}}}const atomObservables={},defaultAtomsValues={},defaultAtomsInAtomic={},defaultFiltersInAtomic={},usedKeys={},defaultFiltersValues={},atomsEffectsCleanupFunctons={},pendingAtoms={},atomicStateContext=React.createContext({prefix:"store"}),AtomicState=({children:g,atoms:d,filters:e,prefix:f="store"})=>{let h=React.useContext(atomicStateContext),a=void 0===f?h.prefix:f;if(d)for(let b in d)void 0===defaultAtomsValues[`${a}-${b}`]&&(defaultAtomsValues[`${a}-${b}`]=d[b],defaultAtomsInAtomic[`${a}-${b}`]=!0);if(e)for(let c in e)void 0===defaultFiltersValues[`${a}-${c}`]&&(defaultFiltersValues[`${a}-${c}`]=e[c],defaultFiltersInAtomic[`${a}-${c}`]=!0);return React.useMemo(()=>g,[f]),React.createElement(atomicStateContext.Provider,{value:{prefix:a}},g)},resolvedAtoms={};function useAtomCreate(a){let{effects:p=[],persist:i,localStoragePersistence:j,sync:q=!0,onSync:r=()=>{}}=a,{prefix:k}=React.useContext(atomicStateContext),b=k+"-"+a.name,[s,t]=React.useState(!1),l=j||i,f=React.useMemo(()=>`${Math.random()}`.split(".")[1],[]);b in atomsEffectsCleanupFunctons||(atomsEffectsCleanupFunctons[b]=[]);let u=void 0!==a.default,d=function(){let f=void 0===defaultAtomsValues[b]&&"function"==typeof a.default,d=f?a.default():a.default instanceof Promise?a.default:void 0,e=d instanceof Promise,c=u&& void 0===defaultAtomsValues[b]?e?a.default:void 0!==d?d:a.default:defaultAtomsValues[b];try{return l?"undefined"!=typeof localStorage&&(void 0===defaultAtomsValues[b]||defaultAtomsInAtomic[b])&&(defaultAtomsInAtomic[b]=!1,defaultAtomsValues[b]=e?void 0:c):void 0===defaultAtomsValues[b]&&(defaultAtomsValues[b]=c),l&&"undefined"!=typeof localStorage&& void 0!==localStorage[b]?defaultAtomsValues[b]:e?void 0:c}catch(g){return c}}(),[m,v]=React.useState(()=>{try{return void 0===defaultFiltersValues[b]?JSON.parse(localStorage[b]):defaultFiltersValues[b]}catch(a){return d}}),[c,w]=React.useState((d instanceof Promise||"function"==typeof d)&& void 0===defaultAtomsValues[b]?void 0:(defaultAtomsValues[b]=d,d));pendingAtoms[b]||(pendingAtoms[b]=0),atomObservables[b]||(atomObservables[b]=createObserver());let{observer:x,notify:n}=atomObservables[b],[g,y]=React.useState(!1),h=React.useRef(!1),e=React.useCallback(async j=>{let k=!1,d="function"==typeof j?await j(c):j,l=await (async()=>{try{return JSON.stringify(d)!==JSON.stringify(defaultAtomsValues[b])}catch(a){return!1}})(),m=await (async()=>{try{if("function"==typeof defaultAtomsValues[b])return!0;if(JSON.stringify(d)===JSON.stringify(a.default)&&!resolvedAtoms[b])return resolvedAtoms[b]=!0,!0}catch(c){return!0}})(),o="function"==typeof defaultAtomsValues[b]||l||m;try{for(let q of atomsEffectsCleanupFunctons[b])q()}catch(s){}finally{atomsEffectsCleanupFunctons[b]=[];try{if(g||h.current)for(let r of p){let i=await r({previous:c,state:d,dispatch:e});void 0===i||i?"function"==typeof i&&atomsEffectsCleanupFunctons[b].push(i):k=!0}}catch(t){y(!0)}finally{k||(defaultAtomsValues[b]=d,o&&n(b,f,d),w(d))}}},[f,n,g,h,c,a.name]);React.useEffect(()=>{async function a(){if("undefined"!=typeof localStorage&& void 0!==localStorage[b])try{if(localStorage[b]!==JSON.stringify(defaultAtomsValues[b])){let a=JSON.parse(localStorage[b]);e(a),await r(a)}}catch(c){}}if(l&&"undefined"!=typeof window){let c=void 0!==window.addEventListener;if(c&&q)return window.addEventListener("storage",a),()=>{window.removeEventListener("storage",a)}}return()=>{}},[a.name]),React.useEffect(()=>{if(void 0!==m&&!h.current){let a=setTimeout(()=>{localStorage[b]!==JSON.stringify(defaultAtomsValues[b])&&e(m),t(!0)},0),c=setTimeout(()=>{v(void 0),h.current=!0},0);return()=>{clearTimeout(a),clearTimeout(c)}}},[m,e,h]),React.useEffect(()=>{async function d(){var d;if(void 0===defaultAtomsValues[b]&&"function"==typeof a.default){if(0===pendingAtoms[b]){pendingAtoms[b]+=1;let g=void 0!==a.default?(async()=>"function"==typeof a.default?a.default():a.default)():void 0;void 0!==g&&g.then(a=>{defaultAtomsValues[b]=a,n(b,f,defaultAtomsValues[b]),e(a)})}else pendingAtoms[b]+=1,(c||defaultAtomsValues[b])&&(null===(d=atomObservables[b])|| void 0===d||d.notify(b,f,void 0!==c?c:defaultAtomsValues[b]))}}d()},[c,a.default,e,a.name,f]),React.useEffect(()=>()=>{pendingAtoms[b]=0},[a.name]),React.useEffect(()=>{let a=async a=>{a.hookCall!==f&&w(a.payload)};return x.addSubscriber(b,a),()=>{x.removeSubscriber(b,a)}},[g]),React.useEffect(()=>{if("undefined"!=typeof localStorage){let a="undefined"!=typeof window,d=a&&"addEventListener"in window;l&&(!d||s)?localStorage[b]!==JSON.stringify(defaultAtomsValues[b])&&localStorage.setItem(b,JSON.stringify(c)):void 0===localStorage[b]||l||localStorage.removeItem(b)}},[a.name,l,c]);let z=React.useMemo(()=>a.actions||{},[]),o=React.useMemo(()=>Object.fromEntries(Object.keys(z).map(a=>[a,b=>z[a]({args:b,state:c,dispatch:e}),])),[c]);return[c,e,o]}const ignoredAtomKeyWarnings={};function atom(a){a.ignoreKeyWarning&&(ignoredAtomKeyWarnings[a.name]=!0),!ignoredAtomKeyWarnings[a.name]&&a.name in usedKeys&&console.warn(`Duplicate atom name '${a.name}' found. This could lead to bugs in atom state. To remove this warning add 'ignoreKeyWarning: true' to all atom definitions that use the name '${a.name}'.`),usedKeys[a.name]=!0;let b=()=>useAtomCreate(a);return b["atom-name"]=a.name,b["init-object"]=a,b}const createAtom=atom,objectFilters={},resolvedFilters={},filterObservables={},subscribedFilters={};function filter(b){let{name:c="",get:d}=b,a=()=>{let i={};a.deps={};let j={},k={},{prefix:e}=React.useContext(atomicStateContext),g=e+"-"+c;filterObservables[g]||(filterObservables[g]=createObserver());let l=filterObservables[g],m=React.useCallback(function(a,b){l.notify(g,a,b)},[e]),n=React.useMemo(()=>({get:b=>("function"!=typeof b?(i[`${e}-${b.name}`]=!0,j[`${e}-${b.name}`]=defaultAtomsValues[`${e}-${b.name}`],a.deps=Object.assign(Object.assign({},a.deps),{[`${e}-${b.name}`]:!0})):(i[`${e}-${b["atom-name"]}`]=!0,j[`${e}-${b["atom-name"]}`]=defaultAtomsValues[`${e}-${b["atom-name"]}`],a.deps=Object.assign(Object.assign({},a.deps),{[`${e}-${b["atom-name"]}`]:!0})),"function"!=typeof b?defaultAtomsValues[`${e}-${b.name}`]:defaultAtomsValues[`${e}-${b["atom-name"]}`]),read:a=>("function"!=typeof a?k[`${e}-${a.name}`]=!0:k[`${e}-${a["filter-name"]}`]=!0,"function"!=typeof a?defaultFiltersValues[`${e}-${a.name}`]:defaultFiltersValues[`${e}-${a["filter-name"]}`])}),[e]),o=React.useMemo(()=>Math.random(),[]),f=function(){try{return void 0!==defaultFiltersValues[g]||defaultFiltersInAtomic[g]?(()=>{let a=setTimeout(()=>{m(o,defaultFiltersValues[g]),clearTimeout(a)},0);return defaultFiltersValues[g]})():(()=>{defaultFiltersValues[g]=b.default;let a;try{if(a=d(n),resolvedFilters[g]=!0,void 0===a)return b.default;(async()=>{defaultFiltersValues[g]=await a})()}catch(c){}finally{return a}})()}catch(a){return b.default}}(),[h,p]=React.useState(f instanceof Promise|| void 0===f?b.default:(defaultFiltersValues[g]=f,f));async function q(a){if("function"==typeof a.payload||JSON.stringify(a.payload)!==JSON.stringify(j[`${a.storeName}`])){`${a.storeName}` in j&&(j[`${a.storeName}`]=a.payload);try{let b=await d(n);defaultFiltersValues[g]=b;let c=setTimeout(()=>{p(b),m(o,b),clearTimeout(c)},0)}catch(e){}}}async function r(a){let{storeName:c,payload:b}=a;o!==a.hookCall&&p(b)}return React.useEffect(()=>{f instanceof Promise&&f.then(a=>{defaultFiltersValues[g]=a,p(a)})},[f]),React.useEffect(()=>{var a,b;if(!subscribedFilters[g]){for(let c in subscribedFilters[g]=!0,defaultFiltersInAtomic[g]&&d(n),i)null===(a=atomObservables[c])|| void 0===a||a.observer.addSubscriber(c,q);for(let e in k)null===(b=filterObservables[e])|| void 0===b||b.observer.addSubscriber(e,q);return()=>{var a,b;for(let c in defaultFiltersInAtomic[g]=!0,i)null===(a=atomObservables[c])|| void 0===a||a.observer.removeSubscriber(c,q);for(let d in k)null===(b=filterObservables[d])|| void 0===b||b.observer.removeSubscriber(d,q)}}},[b,e]),React.useEffect(()=>{var a;return null===(a=l.observer)|| void 0===a||a.addSubscriber(g,r),()=>{var a;subscribedFilters[g]=!1,resolvedFilters[g]=!1,null===(a=null==l?void 0:l.observer)|| void 0===a||a.removeSubscriber(g,r)}},[b,e]),h};return a["filter-name"]=c,a["init-object"]=b,a}function useFilter(a){let{prefix:b}=React.useContext(atomicStateContext);return"function"!=typeof a?(void 0===objectFilters[`${b}-${a.name}`]?objectFilters[`${b}-${a.name}`]=filter(a):objectFilters[`${b}-${a.name}`]["init-object"]!==a&&(objectFilters[`${b}-${a.name}`]=filter(a)),objectFilters[`${b}-${a.name}`]()):a()}const objectAtoms={};function useAtom(a){return"function"!=typeof a&&(void 0===objectAtoms[a.name]?objectAtoms[a.name]=createAtom(a):objectAtoms[a.name]["init-object"]!==a&&(objectAtoms[a.name]=createAtom(a))),"function"!=typeof a?objectAtoms[a.name]():a()}function useValue(a){return useAtom(a)[0]}const useAtomValue=useValue;function useDispatch(a){return useAtom(a)[1]}const useAtomDispatch=useDispatch;function useActions(a){return useAtom(a)[2]}const useAtomActions=useActions,storageOvservable=(()=>{let a=new Observervable;return a})();function useStorage(a){let[b,c]=React.useState(a||{});async function d(){let b={};if("undefined"!=typeof localStorage){for(let a in localStorage)if(!a.match(/clear|getItem|key|length|removeItem|setItem/))try{void 0!==localStorage[a]&&(b[a]=JSON.parse(localStorage[a]))}catch(d){b[a]=localStorage[a]}}c(b)}return React.useEffect(()=>{d()},[]),React.useEffect(()=>(storageOvservable.addSubscriber("store-changed",d),()=>{storageOvservable.removeSubscriber("store-changed",d)}),[]),b}const storage={set(b,a){"undefined"!=typeof localStorage&&"function"==typeof localStorage.setItem&&(localStorage.setItem(b,JSON.stringify(a)),storageOvservable.update("store-changed",a))},async remove(a){"undefined"!=typeof localStorage&&"function"==typeof localStorage.removeItem&&(localStorage.removeItem(a),storageOvservable.update("store-changed",{}))},get(b,a=null){if("undefined"==typeof localStorage)return a;if("function"==typeof localStorage.getItem)try{return JSON.parse(localStorage.getItem(b))}catch(c){return a}else try{return JSON.parse(localStorage[b])}catch(d){return a}}};function useStorageItem(c,a=null){let[b,d]=React.useState(a),e=()=>{if("undefined"!=typeof localStorage&&JSON.stringify(localStorage[c])!==JSON.stringify(a))try{d(JSON.parse(localStorage[c]))}catch(b){d(a)}};return React.useEffect(()=>(e(),storageOvservable.addSubscriber("store-changed",e),()=>{storageOvservable.removeSubscriber("store-changed",e)}),[]),b}